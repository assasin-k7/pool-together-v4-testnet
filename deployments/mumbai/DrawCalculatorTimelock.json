{
  "address": "0x7bC6Ca69cA2fAcb8A3f80e0aB3cbE32a6259f163",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "contract IDrawCalculator",
          "name": "_calculator",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "_timelockDuration",
          "type": "uint32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract ClaimableDraw",
          "name": "claimableDraw",
          "type": "address"
        }
      ],
      "name": "ClaimableDrawSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract ITicket",
          "name": "ticket",
          "type": "address"
        }
      ],
      "name": "Deployed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousManager",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newManager",
          "type": "address"
        }
      ],
      "name": "ManagerTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "pendingOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipOffered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "duration",
          "type": "uint32"
        }
      ],
      "name": "TimelockDurationSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint128",
              "name": "timestamp",
              "type": "uint128"
            },
            {
              "internalType": "uint32",
              "name": "drawId",
              "type": "uint32"
            }
          ],
          "indexed": false,
          "internalType": "struct IDrawCalculatorTimelock.Timelock",
          "name": "timelock",
          "type": "tuple"
        }
      ],
      "name": "TimelockSet",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "uint32[]",
          "name": "drawIds",
          "type": "uint32[]"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "calculate",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "claimOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDrawCalculator",
      "outputs": [
        {
          "internalType": "contract IDrawCalculator",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTimelock",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint128",
              "name": "timestamp",
              "type": "uint128"
            },
            {
              "internalType": "uint32",
              "name": "drawId",
              "type": "uint32"
            }
          ],
          "internalType": "struct IDrawCalculatorTimelock.Timelock",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTimelockDuration",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "hasElapsed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_drawId",
          "type": "uint32"
        }
      ],
      "name": "lock",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "manager",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pendingOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newManager",
          "type": "address"
        }
      ],
      "name": "setManager",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint128",
              "name": "timestamp",
              "type": "uint128"
            },
            {
              "internalType": "uint32",
              "name": "drawId",
              "type": "uint32"
            }
          ],
          "internalType": "struct IDrawCalculatorTimelock.Timelock",
          "name": "_timelock",
          "type": "tuple"
        }
      ],
      "name": "setTimelock",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_timelockDuration",
          "type": "uint32"
        }
      ],
      "name": "setTimelockDuration",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x5609e8ca8d40cdb094cc544b9b924e182e04b55b23dbe2ffbb08591ec0edc5ba",
  "receipt": {
    "to": null,
    "from": "0xE0F4217390221aF47855E094F6e112D43C8698fE",
    "contractAddress": "0x7bC6Ca69cA2fAcb8A3f80e0aB3cbE32a6259f163",
    "transactionIndex": 0,
    "gasUsed": "1054308",
    "logsBloom": "0x00000000010000000000000000000040000000000000000000800000000000000000000000000000000000000000000000018020000000000000000000000000000000000000000000000000000000800001000000000000000100400000000000000000020000000000000000000800008000008000000080000000000000400000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000024000000000000000000001000000000000000000000000000000100000000020000000000000000200000000000000000000000000000000000000000000100000",
    "blockHash": "0x9d536a20dd37ce929098686770f994fa3d94add32dbc36dd05a48a1b0ec93ffb",
    "transactionHash": "0x5609e8ca8d40cdb094cc544b9b924e182e04b55b23dbe2ffbb08591ec0edc5ba",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 19352969,
        "transactionHash": "0x5609e8ca8d40cdb094cc544b9b924e182e04b55b23dbe2ffbb08591ec0edc5ba",
        "address": "0x7bC6Ca69cA2fAcb8A3f80e0aB3cbE32a6259f163",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000e0f4217390221af47855e094f6e112d43c8698fe"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0x9d536a20dd37ce929098686770f994fa3d94add32dbc36dd05a48a1b0ec93ffb"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 19352969,
        "transactionHash": "0x5609e8ca8d40cdb094cc544b9b924e182e04b55b23dbe2ffbb08591ec0edc5ba",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000e0f4217390221af47855e094f6e112d43c8698fe",
          "0x000000000000000000000000e4b8e9222704401ad16d4d826732953daf07c7e2"
        ],
        "data": "0x000000000000000000000000000000000000000000000000004ae9c0347a20000000000000000000000000000000000000000000000000000488fa3770625a0000000000000000000000000000000000000000000000000000abf4f5ab8f9200000000000000000000000000000000000000000000000000043e10773be83a0000000000000000000000000000000000000000000000000000f6deb5e009b200",
        "logIndex": 1,
        "blockHash": "0x9d536a20dd37ce929098686770f994fa3d94add32dbc36dd05a48a1b0ec93ffb"
      }
    ],
    "blockNumber": 19352969,
    "cumulativeGasUsed": "1054308",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xE0F4217390221aF47855E094F6e112D43C8698fE",
    "0xB4760E772F7a4B49d94Ae7973838ff1Ae534559A",
    300
  ],
  "solcInputHash": "b0872f2c20298ba87c0d5bbb50dadae3",
  "metadata": "{\"compiler\":{\"version\":\"0.8.6+commit.11564f7e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"contract IDrawCalculator\",\"name\":\"_calculator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_timelockDuration\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ClaimableDraw\",\"name\":\"claimableDraw\",\"type\":\"address\"}],\"name\":\"ClaimableDrawSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ITicket\",\"name\":\"ticket\",\"type\":\"address\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagerTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipOffered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"}],\"name\":\"TimelockDurationSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"timestamp\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"drawId\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct IDrawCalculatorTimelock.Timelock\",\"name\":\"timelock\",\"type\":\"tuple\"}],\"name\":\"TimelockSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint32[]\",\"name\":\"drawIds\",\"type\":\"uint32[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"calculate\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDrawCalculator\",\"outputs\":[{\"internalType\":\"contract IDrawCalculator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimelock\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"timestamp\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"drawId\",\"type\":\"uint32\"}],\"internalType\":\"struct IDrawCalculatorTimelock.Timelock\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimelockDuration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasElapsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_drawId\",\"type\":\"uint32\"}],\"name\":\"lock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newManager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"timestamp\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"drawId\",\"type\":\"uint32\"}],\"internalType\":\"struct IDrawCalculatorTimelock.Timelock\",\"name\":\"_timelock\",\"type\":\"tuple\"}],\"name\":\"setTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_timelockDuration\",\"type\":\"uint32\"}],\"name\":\"setTimelockDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"PoolTogether Inc Team\",\"kind\":\"dev\",\"methods\":{\"calculate(address,uint32[],bytes)\":{\"details\":\"Will enforce a \\\"cooldown period between when a Draw is pushed and when users can start to claim prizes. \",\"params\":{\"data\":\"Encoded pick indices\",\"drawIds\":\"Draw.drawId\",\"user\":\"User address\"},\"returns\":{\"_0\":\"Prizes awardable array\"}},\"claimOwnership()\":{\"details\":\"This function is only callable by the `_pendingOwner`.\"},\"constructor\":{\"params\":{\"_calculator\":\"DrawCalculator address\",\"_timelockDuration\":\"Elapsed seconds before new Draw is available\"}},\"getDrawCalculator()\":{\"returns\":{\"_0\":\"IDrawCalculator\"}},\"getTimelock()\":{\"returns\":{\"_0\":\"Timelock\"}},\"getTimelockDuration()\":{\"returns\":{\"_0\":\"Seconds to pass before Draw is valid.\"}},\"hasElapsed()\":{\"returns\":{\"_0\":\"True if timelockDuration, since last timelock has elapsed, false otherwse.\"}},\"lock(uint32)\":{\"details\":\"Restricts new draws by forcing a push timelock.\",\"params\":{\"_drawId\":\"Draw id\"}},\"manager()\":{\"returns\":{\"_0\":\"Current `_manager` address.\"}},\"pendingOwner()\":{\"returns\":{\"_0\":\"Current `_pendingOwner` address.\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"setManager(address)\":{\"details\":\"Throws if called by any account other than the owner.\",\"params\":{\"_newManager\":\"New _manager address.\"},\"returns\":{\"_0\":\"Boolean to indicate if the operation was successful or not.\"}},\"setTimelock((uint128,uint32))\":{\"details\":\"Set new Timelock struct and emit TimelockSet event.\"},\"setTimelockDuration(uint32)\":{\"details\":\"Set new timelockDuration and emit TimelockDurationSet event.\"},\"transferOwnership(address)\":{\"params\":{\"_newOwner\":\"Address to transfer ownership to.\"}}},\"title\":\"PoolTogether V4 OracleTimelock\",\"version\":1},\"userdoc\":{\"events\":{\"ClaimableDrawSet(address)\":{\"notice\":\"Emitted when the claimableDraw is set/updated\"},\"Deployed(address)\":{\"notice\":\"Emitted when the contract is initialized\"}},\"kind\":\"user\",\"methods\":{\"calculate(address,uint32[],bytes)\":{\"notice\":\"Routes claim/calculate requests between ClaimableDraw and DrawCalculator.\"},\"claimOwnership()\":{\"notice\":\"Allows the `_pendingOwner` address to finalize the transfer.\"},\"constructor\":{\"notice\":\"Initialize DrawSettingsTimelockTrigger smart contract.\"},\"getDrawCalculator()\":{\"notice\":\"Read internal DrawCalculator variable.\"},\"getTimelock()\":{\"notice\":\"Read internal Timelock struct.\"},\"getTimelockDuration()\":{\"notice\":\"Read internal timelockDuration variable.\"},\"hasElapsed()\":{\"notice\":\"Returns bool for timelockDuration elapsing. \"},\"lock(uint32)\":{\"notice\":\"Push Draw onto draws ring buffer history.\"},\"manager()\":{\"notice\":\"Gets current `_manager`.\"},\"owner()\":{\"notice\":\"Returns the address of the current owner.\"},\"pendingOwner()\":{\"notice\":\"Gets current `_pendingOwner`.\"},\"renounceOwnership()\":{\"notice\":\"Renounce ownership of the contract.\"},\"setManager(address)\":{\"notice\":\"Set or change of manager.\"},\"setTimelock((uint128,uint32))\":{\"notice\":\"Set new Timelock struct.\"},\"setTimelockDuration(uint32)\":{\"notice\":\"Set new timelockDuration.\"},\"transferOwnership(address)\":{\"notice\":\"Allows current owner to set the `_pendingOwner` address.\"}},\"notice\":\"OracleTimelock(s) acts as an intermediary between multiple V4 smart contracts. The OracleTimelock is responsible for pushing Draws to a DrawHistory and routing claim requests from a ClaimableDraw to a DrawCalculator. The primary objective is to  include a \\\"cooldown\\\" period for all new Draws. Allowing the correction of a malicously set Draw in the unfortunate event an Owner is compromised.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"@pooltogether/v4-oracle-timelocks/contracts/DrawCalculatorTimelock.sol\":\"DrawCalculatorTimelock\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x02348b2e4b9f3200c7e3907c5c2661643a6d8520e9f79939fbb9b4005a54894d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3336baae5cf23e94274d75336e2d412193be508504aee185e61dc7d58cd05c8a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x08d867b4c0bb782b9135691fa732b6846e0f133006489c3aa505abd1f6de56cb\",\"license\":\"MIT\"},\"@pooltogether/owner-manager-contracts/contracts/Manageable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Abstract manageable contract that can be inherited by other contracts\\n * @notice Contract module based on Ownable which provides a basic access control mechanism, where\\n * there is an owner and a manager that can be granted exclusive access to specific functions.\\n *\\n * By default, the owner is the deployer of the contract.\\n *\\n * The owner account is set through a two steps process.\\n *      1. The current `owner` calls {transferOwnership} to set a `pendingOwner`\\n *      2. The `pendingOwner` calls {acceptOwnership} to accept the ownership transfer\\n *\\n * The manager account needs to be set using {setManager}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyManager`, which can be applied to your functions to restrict their use to\\n * the manager.\\n */\\nabstract contract Manageable is Ownable {\\n    address private _manager;\\n\\n    /**\\n     * @dev Emitted when `_manager` has been changed.\\n     * @param previousManager previous `_manager` address.\\n     * @param newManager new `_manager` address.\\n     */\\n    event ManagerTransferred(address indexed previousManager, address indexed newManager);\\n\\n    /* ============ External Functions ============ */\\n\\n    /**\\n     * @notice Gets current `_manager`.\\n     * @return Current `_manager` address.\\n     */\\n    function manager() public view virtual returns (address) {\\n        return _manager;\\n    }\\n\\n    /**\\n     * @notice Set or change of manager.\\n     * @dev Throws if called by any account other than the owner.\\n     * @param _newManager New _manager address.\\n     * @return Boolean to indicate if the operation was successful or not.\\n     */\\n    function setManager(address _newManager) external onlyOwner returns (bool) {\\n        return _setManager(_newManager);\\n    }\\n\\n    /* ============ Internal Functions ============ */\\n\\n    /**\\n     * @notice Set or change of manager.\\n     * @param _newManager New _manager address.\\n     * @return Boolean to indicate if the operation was successful or not.\\n     */\\n    function _setManager(address _newManager) private returns (bool) {\\n        address _previousManager = _manager;\\n\\n        require(_newManager != _previousManager, \\\"Manageable/existing-manager-address\\\");\\n\\n        _manager = _newManager;\\n\\n        emit ManagerTransferred(_previousManager, _newManager);\\n        return true;\\n    }\\n\\n    /* ============ Modifier Functions ============ */\\n\\n    /**\\n     * @dev Throws if called by any account other than the manager.\\n     */\\n    modifier onlyManager() {\\n        require(manager() == msg.sender, \\\"Manageable/caller-not-manager\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the manager or the owner.\\n     */\\n    modifier onlyManagerOrOwner() {\\n        require(manager() == msg.sender || owner() == msg.sender, \\\"Manageable/caller-not-manager-or-owner\\\");\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0xdd8ac008df192c6aa4df83e7037ab090970fda38e1f9fd712bc0ab5e0485fc04\",\"license\":\"GPL-3.0\"},\"@pooltogether/owner-manager-contracts/contracts/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Abstract ownable contract that can be inherited by other contracts\\n * @notice Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner is the deployer of the contract.\\n *\\n * The owner account is set through a two steps process.\\n *      1. The current `owner` calls {transferOwnership} to set a `pendingOwner`\\n *      2. The `pendingOwner` calls {acceptOwnership} to accept the ownership transfer\\n *\\n * The manager account needs to be set using {setManager}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable {\\n    address private _owner;\\n    address private _pendingOwner;\\n\\n    /**\\n     * @dev Emitted when `_pendingOwner` has been changed.\\n     * @param pendingOwner new `_pendingOwner` address.\\n     */\\n    event OwnershipOffered(address indexed pendingOwner);\\n\\n    /**\\n     * @dev Emitted when `_owner` has been changed.\\n     * @param previousOwner previous `_owner` address.\\n     * @param newOwner new `_owner` address.\\n     */\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /* ============ Deploy ============ */\\n\\n    /**\\n     * @notice Initializes the contract setting `_initialOwner` as the initial owner.\\n     * @param _initialOwner Initial owner of the contract.\\n     */\\n    constructor(address _initialOwner) {\\n        _setOwner(_initialOwner);\\n    }\\n\\n    /* ============ External Functions ============ */\\n\\n    /**\\n     * @notice Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @notice Gets current `_pendingOwner`.\\n     * @return Current `_pendingOwner` address.\\n     */\\n    function pendingOwner() external view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @notice Renounce ownership of the contract.\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() external virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n    * @notice Allows current owner to set the `_pendingOwner` address.\\n    * @param _newOwner Address to transfer ownership to.\\n    */\\n    function transferOwnership(address _newOwner) external onlyOwner {\\n        require(_newOwner != address(0), \\\"Ownable/pendingOwner-not-zero-address\\\");\\n\\n        _pendingOwner = _newOwner;\\n\\n        emit OwnershipOffered(_newOwner);\\n    }\\n\\n    /**\\n    * @notice Allows the `_pendingOwner` address to finalize the transfer.\\n    * @dev This function is only callable by the `_pendingOwner`.\\n    */\\n    function claimOwnership() external onlyPendingOwner {\\n        _setOwner(_pendingOwner);\\n        _pendingOwner = address(0);\\n    }\\n\\n    /* ============ Internal Functions ============ */\\n\\n    /**\\n     * @notice Internal function to set the `_owner` of the contract.\\n     * @param _newOwner New `_owner` address.\\n     */\\n    function _setOwner(address _newOwner) private {\\n        address _oldOwner = _owner;\\n        _owner = _newOwner;\\n        emit OwnershipTransferred(_oldOwner, _newOwner);\\n    }\\n\\n    /* ============ Modifier Functions ============ */\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"Ownable/caller-not-owner\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @dev Throws if called by any account other than the `pendingOwner`.\\n    */\\n    modifier onlyPendingOwner() {\\n        require(msg.sender == _pendingOwner, \\\"Ownable/caller-not-pendingOwner\\\");\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0xfd0fd374812c8af45f2633cc7cc4811ccb7bad0a3902a43aded35939eb4a00d1\",\"license\":\"GPL-3.0\"},\"@pooltogether/v4-core/contracts/ClaimableDraw.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@pooltogether/owner-manager-contracts/contracts/Ownable.sol\\\";\\n\\nimport \\\"./interfaces/IClaimableDraw.sol\\\";\\nimport \\\"./interfaces/IDrawCalculator.sol\\\";\\nimport \\\"./libraries/DrawLib.sol\\\";\\n\\n/**\\n  * @title  PoolTogether V4 ClaimableDraw\\n  * @author PoolTogether Inc Team\\n  * @notice The ClaimableDraw distributes claimable draw prizes to users via a pull model.\\n            Managing the regularly captured PrizePool interest, a ClaimableDraw is the\\n            entrypoint for users to submit Draw.drawId(s) and winning pick indices.\\n            Communicating with a DrawCalculator, the ClaimableDraw will determine the maximum\\n            prize payout and transfer those tokens directly to a user address. \\n*/\\ncontract ClaimableDraw is IClaimableDraw, Ownable {\\n  using SafeERC20 for IERC20;\\n\\n  /* ============ Global Variables ============ */\\n\\n  /// @notice The Draw Calculator to use\\n  IDrawCalculator internal drawCalculator;\\n\\n  /// @notice Token address\\n  IERC20 internal immutable token;\\n\\n  /// @notice Maps users => drawId => paid out balance\\n  mapping(address => mapping(uint256 => uint256)) internal userDrawPayouts;\\n\\n  /* ============ Initialize ============ */\\n\\n  /**\\n    * @notice Initialize ClaimableDraw smart contract.\\n    * @param _owner           Address of the ClaimableDraw owner\\n    * @param _token           Token address\\n    * @param _drawCalculator DrawCalculator address\\n  */\\n  constructor(\\n    address _owner,\\n    IERC20 _token,\\n    IDrawCalculator _drawCalculator\\n  ) Ownable(_owner) {\\n    _setDrawCalculator(_drawCalculator);\\n    require(address(_token) != address(0), \\\"ClaimableDraw/token-not-zero-address\\\" );\\n    token = _token;\\n    emit TokenSet(_token);\\n  }\\n\\n  /* ============ External View Functions ============ */\\n\\n  /**\\n    * @notice Read DrawCalculator\\n    * @return IDrawCalculator\\n  */\\n  function getDrawCalculator() external override view returns (IDrawCalculator) {\\n    return drawCalculator;\\n  }\\n\\n  /**\\n    * @notice Get the amount that a user has already been paid out for a draw\\n    * @param user   User address\\n    * @param drawId Draw ID\\n  */\\n  function getDrawPayoutBalanceOf(address user, uint32 drawId) external override view returns (uint256) {\\n    return _getDrawPayoutBalanceOf(user, drawId);\\n  }\\n\\n  /**\\n    * @notice Read global Ticket variable.\\n    * @return IERC20\\n  */\\n  function getToken() external override view returns (IERC20) {\\n    return token;\\n  }\\n\\n  function _getDrawPayoutBalanceOf(address _user, uint32 _drawId) internal view returns (uint256) {\\n    return userDrawPayouts[_user][_drawId];\\n  }\\n\\n  function _setDrawPayoutBalanceOf(address _user, uint32 _drawId, uint256 _payout) internal {\\n    userDrawPayouts[_user][_drawId] = _payout;\\n  }\\n\\n  /* ============ External Functions ============ */\\n\\n  /**\\n    * @notice Claim a user token payouts via a collection of draw ids and pick indices.\\n    * @param _user             Address of user to claim awards for. Does NOT need to be msg.sender\\n    * @param _drawIds          Draw IDs from global DrawHistory reference\\n    * @param _data             The data to pass to the draw calculator.\\n    * @return Actual claim payout.  If the user has previously claimed a draw, this may be less.\\n  */\\n  function claim(address _user, uint32[] calldata _drawIds, bytes calldata _data) external override returns (uint256) {\\n    uint256 totalPayout;\\n\\n    uint256[] memory drawPayouts = drawCalculator.calculate(_user, _drawIds, _data);  // CALL\\n    for (uint256 payoutIndex = 0; payoutIndex < drawPayouts.length; payoutIndex++) {\\n      uint32 drawId = _drawIds[payoutIndex];\\n      uint256 payout = drawPayouts[payoutIndex];\\n      uint256 oldPayout = _getDrawPayoutBalanceOf(_user, drawId);\\n      uint256 payoutDiff = 0;\\n      if (payout > oldPayout) {\\n        payoutDiff = payout - oldPayout;\\n        _setDrawPayoutBalanceOf(_user, drawId, payout);\\n      }\\n      // helpfully short-circuit, in case the user screwed something up.\\n      require(payoutDiff > 0, \\\"ClaimableDraw/zero-payout\\\");\\n      totalPayout += payoutDiff;\\n      emit ClaimedDraw(_user, drawId, payoutDiff);\\n    }\\n\\n    _awardPayout(_user, totalPayout);\\n\\n    return totalPayout;\\n  }\\n\\n  /**\\n    * @notice Sets DrawCalculator reference for individual draw id.\\n    * @param _newCalculator  DrawCalculator address\\n    * @return New DrawCalculator address\\n  */\\n  function setDrawCalculator(IDrawCalculator _newCalculator) external override onlyOwner returns (IDrawCalculator) {\\n    _setDrawCalculator(_newCalculator);\\n    return _newCalculator;\\n  }\\n\\n  /**\\n    * @notice Sets DrawCalculator reference for individual draw id.\\n    * @param _newCalculator  DrawCalculator address\\n  */\\n  function _setDrawCalculator(IDrawCalculator _newCalculator) internal {\\n    require(address(_newCalculator) != address(0), \\\"ClaimableDraw/calc-not-zero\\\");\\n    drawCalculator = _newCalculator;\\n    emit DrawCalculatorSet(_newCalculator);\\n  }\\n\\n  /**\\n    * @notice Transfer claimed draw(s) total payout to user.\\n    * @param _to      User address\\n    * @param _amount  Transfer amount\\n  */\\n  function _awardPayout(address _to, uint256 _amount) internal {\\n    token.safeTransfer(_to, _amount);\\n  }\\n\\n  /**\\n    * @notice Transfer ERC20 tokens out of this contract.\\n    * @dev    This function is only callable by the owner.\\n    * @param _erc20Token ERC20 token to transfer.\\n    * @param _to Recipient of the tokens.\\n    * @param _amount Amount of tokens to transfer.\\n    * @return true if operation is successful.\\n  */\\n  function withdrawERC20(IERC20 _erc20Token, address _to, uint256 _amount) external override onlyOwner returns (bool) {\\n    require(_to != address(0), \\\"ClaimableDraw/recipient-not-zero-address\\\");\\n    require(address(_erc20Token) != address(0), \\\"ClaimableDraw/ERC20-not-zero-address\\\");\\n    _erc20Token.safeTransfer(_to, _amount);\\n    emit ERC20Withdrawn(_erc20Token, _to, _amount);\\n    return true;\\n  }\\n}\\n\",\"keccak256\":\"0x80ab52495aada4db4aac4a07fb9e2f012a3cf0b281a1922d567f1b0d8ab390ba\",\"license\":\"GPL-3.0\"},\"@pooltogether/v4-core/contracts/interfaces/IClaimableDraw.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IDrawHistory.sol\\\";\\nimport \\\"./IDrawCalculator.sol\\\";\\nimport \\\"../libraries/DrawLib.sol\\\";\\n\\ninterface IClaimableDraw {\\n\\n  /**\\n    * @notice Emitted when a user has claimed N draw payouts.\\n    * @param user        User address receiving draw claim payouts\\n    * @param drawId      Draw id that was paid out\\n    * @param payout Payout for draw\\n  */\\n  event ClaimedDraw (\\n    address indexed user,\\n    uint32 indexed drawId,\\n    uint256 payout\\n  );\\n\\n  /**\\n    * @notice Emitted when a DrawCalculator is set\\n    * @param calculator DrawCalculator address\\n  */\\n  event DrawCalculatorSet (\\n    IDrawCalculator indexed calculator\\n  );\\n\\n  /**\\n    * @notice Emitted when a global Ticket variable is set.\\n    * @param token Token address\\n  */\\n  event TokenSet (\\n    IERC20 indexed token\\n  );\\n\\n  /**\\n    * @notice Emitted when ERC20 tokens are withdrawn from the claimable draw.\\n    * @param token ERC20 token transferred.\\n    * @param to Address that received funds.\\n    * @param amount Amount of tokens transferred.\\n  */\\n  event ERC20Withdrawn(\\n    IERC20 indexed token,\\n    address indexed to,\\n    uint256 amount\\n  );\\n\\n  function claim(address _user, uint32[] calldata _drawIds, bytes calldata _data) external returns (uint256);\\n  function getDrawCalculator() external view returns (IDrawCalculator);\\n  function getDrawPayoutBalanceOf(address user, uint32 drawId) external view returns (uint256);\\n  function getToken() external view returns (IERC20);\\n  function setDrawCalculator(IDrawCalculator _newCalculator) external returns(IDrawCalculator);\\n  function withdrawERC20(IERC20 _erc20Token, address _to, uint256 _amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0xf500f8800e41f64616220cd14f98989a73f1cc4286cf07c046f1e9c95bb2844f\",\"license\":\"GPL-3.0\"},\"@pooltogether/v4-core/contracts/interfaces/IDrawCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.6;\\n\\nimport \\\"./ITicket.sol\\\";\\nimport \\\"../ClaimableDraw.sol\\\";\\nimport \\\"../libraries/DrawLib.sol\\\";\\n\\ninterface IDrawCalculator {\\n\\n  ///@notice Emitted when the contract is initialized\\n  event Deployed(ITicket indexed ticket);\\n\\n  ///@notice Emitted when the claimableDraw is set/updated\\n  event ClaimableDrawSet(ClaimableDraw indexed claimableDraw);\\n\\n  function calculate(address user, uint32[] calldata drawIds, bytes calldata data)\\n    external view returns (uint256[] memory);\\n}\\n\",\"keccak256\":\"0x1846f7dc3345079eced9502623569249ce35cdf9cb0fdc2d5c765ebfdcfa99b2\",\"license\":\"GPL-3.0\"},\"@pooltogether/v4-core/contracts/interfaces/IDrawHistory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.6;\\n\\nimport \\\"../libraries/DrawLib.sol\\\";\\n\\ninterface IDrawHistory {\\n  \\n  /**\\n    * @notice Emit when a new draw has been created.\\n    * @param drawId       Draw id\\n    * @param timestamp    Epoch timestamp when the draw is created.\\n    * @param winningRandomNumber Randomly generated number used to calculate draw winning numbers\\n  */\\n  event DrawSet (\\n    uint32 drawId,\\n    uint32 timestamp,\\n    uint256 winningRandomNumber\\n  );\\n\\n  function getDraws(uint32[] calldata drawIds) external view returns (DrawLib.Draw[] memory);\\n  function getDraw(uint32 drawId) external view returns (DrawLib.Draw memory);\\n  function pushDraw(DrawLib.Draw calldata draw) external returns(uint32);\\n  function setDraw(DrawLib.Draw calldata draw) external returns(uint32); // maybe return drawIndex\\n}\",\"keccak256\":\"0x13b05ac622ee31cf26fecf2bb9943537872991d0d8d1fe4d34c796f34556c606\",\"license\":\"GPL-3.0\"},\"@pooltogether/v4-core/contracts/interfaces/ITicket.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"../libraries/TwabLibrary.sol\\\";\\n\\ninterface ITicket {\\n\\n  event Delegated(\\n    address indexed user,\\n    address indexed delegate\\n  );\\n\\n  /// @notice Emitted when ticket is initialized.\\n  /// @param name Ticket name (eg: PoolTogether Dai Ticket (Compound)).\\n  /// @param symbol Ticket symbol (eg: PcDAI).\\n  /// @param decimals Ticket decimals.\\n  /// @param controller Token controller address.\\n  event TicketInitialized(\\n    string name,\\n    string symbol,\\n    uint8 decimals,\\n    address controller\\n  );\\n\\n  /// @notice Emitted when a new TWAB has been recorded.\\n  /// @param ticketHolder The Ticket holder address.\\n  /// @param user The recipient of the ticket power (may be the same as the ticketHolder)\\n  /// @param newTwab Updated TWAB of a ticket holder after a successful TWAB recording.\\n  event NewUserTwab(\\n    address indexed ticketHolder,\\n    address indexed user,\\n    ObservationLib.Observation newTwab\\n  );\\n\\n  /// @notice Emitted when a new total supply TWAB has been recorded.\\n  /// @param newTotalSupplyTwab Updated TWAB of tickets total supply after a successful total supply TWAB recording.\\n  event NewTotalSupplyTwab(\\n    ObservationLib.Observation newTotalSupplyTwab\\n  );\\n  \\n  function getBalanceAt(address user, uint256 timestamp) external view returns(uint256);\\n  function getBalancesAt(address user, uint32[] calldata timestamp) external view returns(uint256[] memory);\\n  function getAverageBalanceBetween(address user, uint256 startTime, uint256 endTime) external view returns (uint256);\\n  function getAverageBalancesBetween(address user, uint32[] calldata startTimes, uint32[] calldata endTimes) external view returns (uint256[] memory);\\n  function getTotalSupply(uint32 timestamp) external view returns(uint256);\\n  function getTotalSupplies(uint32[] calldata timestamp) external view returns(uint256[] memory);\\n  function getAverageTotalSuppliesBetween(uint32[] calldata startTimes, uint32[] calldata endTimes) external view returns(uint256[] memory);\\n}\\n\",\"keccak256\":\"0x0eca49ebc470f1d478fc88f7abb16eb91616aa427ff1d338bcd84fae7376efa9\",\"license\":\"GPL-3.0\"},\"@pooltogether/v4-core/contracts/libraries/DrawLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.6;\\n\\nlibrary DrawLib{\\n\\n    struct Draw {\\n        uint256 winningRandomNumber;\\n        uint32 timestamp;\\n        uint32 drawId;\\n    }\\n\\n    ///@notice Draw settings for the tsunami draw calculator\\n    ///@param bitRangeSize Decimal representation of bitRangeSize\\n    ///@param matchCardinality The bitRangeSize's to consider in the 256 random numbers. Must be > 1 and < 256/bitRangeSize\\n    ///@param numberOfPicks Number of picks this Draw has (may vary network to network)\\n    ///@param maxPicksPerUser Maximum number of picks a user can make in this Draw\\n    ///@param distributions Array of prize distribution percentages, expressed in fraction form with base 1e18. Max sum of these <= 1 Ether. ordering: index0: grandPrize, index1: runnerUp, etc.\\n    ///@param prize Total prize amount available in this draw calculator for this Draw (may vary from network to network)\\n    struct TsunamiDrawSettings {\\n        uint8 bitRangeSize;\\n        uint8 matchCardinality;\\n        uint32 drawStartTimestampOffset;\\n        uint32 drawEndTimestampOffset;\\n        uint32 maxPicksPerUser;\\n        uint136 numberOfPicks;\\n        uint32[] distributions;\\n        uint256 prize;\\n    }\\n}\",\"keccak256\":\"0xb216d3c74904241eb73621750a2d6d561b05bb95489af807c70140ef8579b73b\",\"license\":\"GPL-3.0\"},\"@pooltogether/v4-core/contracts/libraries/ObservationLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport \\\"./OverflowSafeComparator.sol\\\";\\nimport \\\"./RingBuffer.sol\\\";\\n\\n/// @title Time-Weighted Average Balance Library\\n/// @notice This library allows you to efficiently track a user's historic balance.  You can get a\\n/// @author PoolTogether Inc.\\nlibrary ObservationLib {\\n  using OverflowSafeComparator for uint32;\\n  using SafeCast for uint256;\\n\\n  /// @notice The maximum number of observation entries\\n  uint16 public constant MAX_CARDINALITY = 65535;\\n\\n  /// @notice Time Weighted Average Balance (Observation).\\n  /// @param amount `amount` at `timestamp`.\\n  /// @param timestamp Recorded `timestamp`.\\n  struct Observation {\\n    uint224 amount;\\n    uint32 timestamp;\\n  }\\n\\n  /// @notice Fetches Observations `beforeOrAt` and `atOrAfter` a `_target`, eg: where [`beforeOrAt`, `atOrAfter`] is satisfied.\\n  /// The result may be the same Observation, or adjacent Observations.\\n  /// @dev The answer must be contained in the array, used when the target is located within the stored Observation.\\n  /// boundaries: older than the most recent Observation and younger, or the same age as, the oldest Observation.\\n  /// @param _observations List of Observations to search through.\\n  /// @param _observationIndex Index of the Observation to start searching from.\\n  /// @param _target Timestamp at which the reserved Observation should be for.\\n  /// @return beforeOrAt Observation recorded before, or at, the target.\\n  /// @return atOrAfter Observation recorded at, or after, the target.\\n  function binarySearch(\\n    Observation[MAX_CARDINALITY] storage _observations,\\n    uint16 _observationIndex,\\n    uint16 _oldestObservationIndex,\\n    uint32 _target,\\n    uint16 _cardinality,\\n    uint32 _time\\n  ) internal view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\\n    uint256 leftSide = _oldestObservationIndex; // Oldest Observation\\n    uint256 rightSide = _observationIndex < leftSide ? leftSide + _cardinality - 1 : _observationIndex;\\n    uint256 currentIndex;\\n\\n    while (true) {\\n      currentIndex = (leftSide + rightSide) / 2;\\n      beforeOrAt = _observations[uint16(RingBuffer.wrap(currentIndex, _cardinality))];\\n      uint32 beforeOrAtTimestamp = beforeOrAt.timestamp;\\n\\n      // We've landed on an uninitialized timestamp, keep searching higher (more recently)\\n      if (beforeOrAtTimestamp == 0) {\\n        leftSide = currentIndex + 1;\\n        continue;\\n      }\\n\\n      atOrAfter = _observations[uint16(RingBuffer.nextIndex(currentIndex, _cardinality))];\\n\\n      bool targetAtOrAfter = beforeOrAtTimestamp.lte(_target, _time);\\n\\n      // Check if we've found the corresponding Observation\\n      if (targetAtOrAfter && _target.lte(atOrAfter.timestamp, _time)) {\\n        break;\\n      }\\n\\n      // If `beforeOrAtTimestamp` is greater than `_target`, then we keep searching lower\\n      if (!targetAtOrAfter) rightSide = currentIndex - 1;\\n\\n      // Otherwise, we keep searching higher\\n      else leftSide = currentIndex + 1;\\n    }\\n  }\\n\\n}\\n\",\"keccak256\":\"0xe031f5829bc334cbc200576bc7c8d2a8a5814fc0ff9322a4c740c1d0d760e403\",\"license\":\"GPL-3.0\"},\"@pooltogether/v4-core/contracts/libraries/OverflowSafeComparator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.6;\\n\\n/// @title OverflowSafeComparator library to share comparator functions between contracts\\n/// @author PoolTogether Inc.\\nlibrary OverflowSafeComparator {\\n  /// @notice 32-bit timestamps comparator.\\n  /// @dev safe for 0 or 1 overflows, `_a` and `_b` must be chronologically before or equal to time.\\n  /// @param _a A comparison timestamp from which to determine the relative position of `_timestamp`.\\n  /// @param _b Timestamp to compare against `_a`.\\n  /// @param _timestamp A timestamp truncated to 32 bits.\\n  /// @return bool Whether `_a` is chronologically < `_b`.\\n  function lt(\\n      uint32 _a,\\n      uint32 _b,\\n      uint32 _timestamp\\n  ) internal pure returns (bool) {\\n      // No need to adjust if there hasn't been an overflow\\n      if (_a <= _timestamp && _b <= _timestamp) return _a < _b;\\n\\n      uint256 aAdjusted = _a > _timestamp ? _a : _a + 2**32;\\n      uint256 bAdjusted = _b > _timestamp ? _b : _b + 2**32;\\n\\n      return aAdjusted < bAdjusted;\\n  }\\n\\n  /// @notice 32-bit timestamps comparator.\\n  /// @dev safe for 0 or 1 overflows, `_a` and `_b` must be chronologically before or equal to time.\\n  /// @param _a A comparison timestamp from which to determine the relative position of `_timestamp`.\\n  /// @param _b Timestamp to compare against `_a`.\\n  /// @param _timestamp A timestamp truncated to 32 bits.\\n  /// @return bool Whether `_a` is chronologically <= `_b`.\\n  function lte(\\n      uint32 _a,\\n      uint32 _b,\\n      uint32 _timestamp\\n  ) internal pure returns (bool) {\\n      // No need to adjust if there hasn't been an overflow\\n      if (_a <= _timestamp && _b <= _timestamp) return _a <= _b;\\n\\n      uint256 aAdjusted = _a > _timestamp ? _a : _a + 2**32;\\n      uint256 bAdjusted = _b > _timestamp ? _b : _b + 2**32;\\n\\n      return aAdjusted <= bAdjusted;\\n  }\\n\\n  function checkedSub(\\n      uint32 _a,\\n      uint32 _b,\\n      uint32 _timestamp\\n  ) internal pure returns (uint32) {\\n      // No need to adjust if there hasn't been an overflow\\n      if (_a <= _timestamp && _b <= _timestamp) return _a - _b;\\n\\n      uint256 aAdjusted = _a > _timestamp ? _a : _a + 2**32;\\n      uint256 bAdjusted = _b > _timestamp ? _b : _b + 2**32;\\n\\n      return uint32(aAdjusted - bAdjusted);\\n  }\\n}\\n\",\"keccak256\":\"0xde8b2a91634534f6e24bf470d87304176b828231d18dbde45f23c972bc173d3c\",\"license\":\"GPL-3.0\"},\"@pooltogether/v4-core/contracts/libraries/RingBuffer.sol\":{\"content\":\"pragma solidity 0.8.6;\\n\\nlibrary RingBuffer {\\n\\n  /// @notice Returns TWAB index.\\n  /// @dev `twabs` is a circular buffer of `MAX_CARDINALITY` size equal to 32. So the array goes from 0 to 31.\\n  /// @dev In order to navigate the circular buffer, we need to use the modulo operator.\\n  /// @dev For example, if `_index` is equal to 32, `_index % MAX_CARDINALITY` will return 0 and will point to the first element of the array.\\n  /// @param _index Index used to navigate through `twabs` circular buffer.\\n  function wrap(uint256 _index, uint256 _cardinality) internal pure returns (uint256) {\\n    return _index % _cardinality;\\n  }\\n\\n  function offset(uint256 _index, uint256 _amount, uint256 _cardinality) internal pure returns (uint256) {\\n    return (_index + _cardinality - _amount) % _cardinality;\\n  }\\n\\n  /// @notice Returns the index of the last recorded TWAB\\n  /// @param _nextAvailableIndex The next available twab index.  This will be recorded to next.\\n  /// @param _cardinality The cardinality of the TWAB history.\\n  /// @return The index of the last recorded TWAB\\n  function mostRecentIndex(uint256 _nextAvailableIndex, uint256 _cardinality) internal pure returns (uint256) {\\n    if (_cardinality == 0) {\\n      return 0;\\n    }\\n    return (_nextAvailableIndex + uint256(_cardinality) - 1) % _cardinality;\\n  }\\n\\n  function nextIndex(uint256 _currentIndex, uint256 _cardinality) internal pure returns (uint256) {\\n    return (_currentIndex + 1) % _cardinality;\\n  }\\n\\n}\",\"keccak256\":\"0xb055c8f88ea11a451d5950eaea35542833e581dbf075224af6adb40fc9dc4ddc\"},\"@pooltogether/v4-core/contracts/libraries/TwabLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport \\\"./OverflowSafeComparator.sol\\\";\\nimport \\\"./RingBuffer.sol\\\";\\nimport \\\"./ObservationLib.sol\\\";\\n\\n/// @title Time-Weighted Average Balance Library\\n/// @notice This library allows you to efficiently track a user's historic balance.  You can get a\\n/// @author PoolTogether Inc.\\nlibrary TwabLibrary {\\n  using OverflowSafeComparator for uint32;\\n  using SafeCast for uint256;\\n\\n  /// @notice The maximum number of twab entries\\n  uint16 public constant MAX_CARDINALITY = 65535;\\n\\n  /// @notice Ensures the passed cardinality is a minimum of 1\\n  /// @param _cardinality The cardinality to ensure a floor of 1\\n  /// @return Returns 1 if the given cardinality is zero, otherwise return the cardinality\\n  function _minCardinality(uint16 _cardinality) internal pure returns (uint16) {\\n    return _cardinality > 0 ? _cardinality : 1;\\n  }\\n\\n  /// @notice Retrieves TWAB balance.\\n  /// @param _target Timestamp at which the reserved TWAB should be for.\\n  function getBalanceAt(\\n    uint16 _cardinality,\\n    uint16 _nextTwabIndex,\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    uint224 _balance,\\n    uint32 _target,\\n    uint32 _time\\n  ) internal view returns (uint256) {\\n    uint16 cardinality = _minCardinality(_cardinality);\\n    uint16 recentIndex = uint16(RingBuffer.mostRecentIndex(_nextTwabIndex, cardinality));\\n    return getBalanceAt(_twabs, _target, _balance, recentIndex, cardinality, _time);\\n  }\\n\\n  /// @notice Calculates the average balance held by an Account for a given time frame.\\n  /// @param _startTime The start time of the time frame.\\n  /// @param _endTime The end time of the time frame.\\n  /// @param _time The current time\\n  /// @return The average balance that the user held during the time frame.\\n  function getAverageBalanceBetween(\\n    uint16 _cardinality,\\n    uint16 _nextTwabIndex,\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    uint224 _balance,\\n    uint32 _startTime,\\n    uint32 _endTime,\\n    uint32 _time\\n  ) internal view returns (uint256) {\\n    uint16 card = _minCardinality(_cardinality);\\n    uint16 recentIndex = uint16(RingBuffer.mostRecentIndex(_nextTwabIndex, card));\\n    return getAverageBalanceBetween(\\n      _twabs,\\n      _balance,\\n      recentIndex,\\n      _startTime,\\n      _endTime,\\n      card,\\n      _time\\n    );\\n  }\\n\\n  /// @notice Decreases an account's balance and records a new twab.\\n  /// @param _balance The balance held since the last update\\n  /// @param _time The current time\\n  /// @param _ttl The time-to-live for TWABs. This is essentially how long twabs are kept around.  History is not available longer than the time-to-live.\\n  /// @return nextTwabIndex\\n  /// @return cardinality\\n  /// @return twab The user's latest TWAB\\n  /// @return isNew Whether the TWAB is new\\n  function update(\\n    uint224 _balance,\\n    uint16 _nextTwabIndex,\\n    uint16 _cardinality,\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    uint32 _time,\\n    uint32 _ttl\\n  ) internal returns (uint16 nextTwabIndex, uint16 cardinality, ObservationLib.Observation memory twab, bool isNew) {\\n    (nextTwabIndex, cardinality, twab, isNew) = nextTwabWithExpiry(\\n      _twabs,\\n      _balance,\\n      _nextTwabIndex,\\n      _cardinality,\\n      _time,\\n      _ttl\\n    );\\n  }\\n\\n  /// @dev A struct that just used internally to bypass the stack variable limitation\\n  struct AvgHelper {\\n    uint16 twabIndex;\\n    uint16 oldestTwabIndex;\\n    uint32 startTime;\\n    uint32 endTime;\\n    uint16 cardinality;\\n  }\\n\\n  /// @notice Fetches TWABs `beforeOrAt` and `atOrAfter` a `_target`, eg: where [`beforeOrAt`, `atOrAfter`] is satisfied.\\n  /// The result may be the same TWAB, or adjacent TWABs.\\n  /// @dev The answer must be contained in the array, used when the target is located within the stored TWAB.\\n  /// boundaries: older than the most recent TWAB and younger, or the same age as, the oldest TWAB.\\n  /// @param _twabs List of TWABs to search through.\\n  /// @param _twabIndex Index of the TWAB to start searching from.\\n  /// @param _target Timestamp at which the reserved TWAB should be for.\\n  /// @return beforeOrAt TWAB recorded before, or at, the target.\\n  /// @return atOrAfter TWAB recorded at, or after, the target.\\n  function binarySearch(\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    uint16 _twabIndex,\\n    uint16 _oldestTwabIndex,\\n    uint32 _target,\\n    uint16 _cardinality,\\n    uint32 _time\\n  ) internal view returns (ObservationLib.Observation memory beforeOrAt, ObservationLib.Observation memory atOrAfter) {\\n    uint256 leftSide = _oldestTwabIndex; // Oldest TWAB\\n    uint256 rightSide = _twabIndex < leftSide ? leftSide + _cardinality - 1 : _twabIndex;\\n    uint256 currentIndex;\\n\\n    while (true) {\\n      currentIndex = (leftSide + rightSide) / 2;\\n      beforeOrAt = _twabs[uint16(RingBuffer.wrap(currentIndex, _cardinality))];\\n      uint32 beforeOrAtTimestamp = beforeOrAt.timestamp;\\n\\n      // We've landed on an uninitialized timestamp, keep searching higher (more recently)\\n      if (beforeOrAtTimestamp == 0) {\\n        leftSide = currentIndex + 1;\\n        continue;\\n      }\\n\\n      atOrAfter = _twabs[uint16(RingBuffer.nextIndex(currentIndex, _cardinality))];\\n\\n      bool targetAtOrAfter = beforeOrAtTimestamp.lte(_target, _time);\\n\\n      // Check if we've found the corresponding TWAB\\n      if (targetAtOrAfter && _target.lte(atOrAfter.timestamp, _time)) {\\n        break;\\n      }\\n\\n      // If `beforeOrAtTimestamp` is greater than `_target`, then we keep searching lower\\n      if (!targetAtOrAfter) rightSide = currentIndex - 1;\\n\\n      // Otherwise, we keep searching higher\\n      else leftSide = currentIndex + 1;\\n    }\\n  }\\n\\n  /// @notice Calculates the TWAB for a given timestamp.  It interpolates as necessary.\\n  /// @param _twabs The TWAB history\\n  function calculateTwab(\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    ObservationLib.Observation memory newestTwab,\\n    ObservationLib.Observation memory oldestTwab,\\n    uint16 _twabIndex,\\n    uint16 _oldestTwabIndex,\\n    uint32 targetTimestamp,\\n    uint224 _currentBalance,\\n    uint16 _cardinality,\\n    uint32 _time\\n  ) internal view returns (ObservationLib.Observation memory) {\\n    // If `targetTimestamp` is chronologically after the newest TWAB, we extrapolate a new one\\n    if (newestTwab.timestamp.lt(targetTimestamp, _time)) {\\n      return ObservationLib.Observation({\\n        amount: newestTwab.amount + _currentBalance*(targetTimestamp - newestTwab.timestamp),\\n        timestamp: targetTimestamp\\n      });\\n    }\\n\\n    if (newestTwab.timestamp == targetTimestamp) {\\n      return newestTwab;\\n    }\\n\\n    if (oldestTwab.timestamp == targetTimestamp) {\\n      return oldestTwab;\\n    }\\n\\n    // If `targetTimestamp` is chronologically before the oldest TWAB, we create a zero twab\\n    if (targetTimestamp.lt(oldestTwab.timestamp, _time)) {\\n      return ObservationLib.Observation({\\n        amount: 0,\\n        timestamp: targetTimestamp\\n      });\\n    }\\n\\n    // Otherwise, both timestamps must be surrounded by twabs.\\n    (\\n      ObservationLib.Observation memory beforeOrAtStart,\\n      ObservationLib.Observation memory afterOrAtStart\\n    ) = binarySearch(_twabs, _twabIndex, _oldestTwabIndex, targetTimestamp, _cardinality, _time);\\n\\n    uint224 heldBalance = (afterOrAtStart.amount - beforeOrAtStart.amount) / (afterOrAtStart.timestamp - beforeOrAtStart.timestamp);\\n    uint224 amount = beforeOrAtStart.amount + heldBalance * (targetTimestamp - beforeOrAtStart.timestamp);\\n\\n    return ObservationLib.Observation({\\n      amount: amount,\\n      timestamp: targetTimestamp\\n    });\\n  }\\n\\n  function getAverageBalanceBetween(\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    uint224 _currentBalance,\\n    uint16 _twabIndex,\\n    uint32 _startTime,\\n    uint32 _endTime,\\n    uint16 _cardinality,\\n    uint32 _time\\n  ) internal view returns (uint256) {\\n    require(_endTime > _startTime, \\\"TWAB/startTime-gt-than-endTime\\\");\\n\\n    // Find oldest Twab\\n    uint16 oldestTwabIndex = uint16(RingBuffer.nextIndex(_twabIndex, _cardinality));\\n    ObservationLib.Observation memory oldestTwab = _twabs[oldestTwabIndex];\\n    // If the TWAB is not initialized we go to the beginning of the TWAB circular buffer at index 0\\n    if (oldestTwab.timestamp == 0) {\\n      oldestTwabIndex = 0;\\n      oldestTwab = _twabs[0];\\n    }\\n\\n    return _getAverageBalanceBetween(\\n      _twabs,\\n      _currentBalance,\\n      AvgHelper({\\n        twabIndex: _twabIndex,\\n        oldestTwabIndex: oldestTwabIndex,\\n        startTime: _startTime,\\n        endTime: _endTime,\\n        cardinality: _cardinality\\n      }),\\n      oldestTwab,\\n      _time\\n    );\\n  }\\n\\n  function _getAverageBalanceBetween(\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    uint224 _currentBalance,\\n    AvgHelper memory helper,\\n    ObservationLib.Observation memory _oldestTwab,\\n    uint32 _time\\n  ) private view returns (uint256) {\\n    uint32 endTime = helper.endTime > _time ? _time : helper.endTime;\\n\\n    ObservationLib.Observation memory newestTwab = _twabs[helper.twabIndex];\\n\\n    ObservationLib.Observation memory startTwab = calculateTwab(\\n      _twabs, newestTwab, _oldestTwab, helper.twabIndex, helper.oldestTwabIndex, helper.startTime, _currentBalance, helper.cardinality, _time\\n    );\\n    ObservationLib.Observation memory endTwab = calculateTwab(\\n      _twabs, newestTwab, _oldestTwab, helper.twabIndex, helper.oldestTwabIndex, endTime, _currentBalance, helper.cardinality, _time\\n    );\\n\\n    // Difference in amount / time\\n    return (endTwab.amount - startTwab.amount) / (endTwab.timestamp - startTwab.timestamp);\\n  }\\n\\n  /// @notice Retrieves amount at `_target` timestamp\\n  /// @param _twabs List of TWABs to search through.\\n  /// @param _currentBalance Most recent amount recorded.\\n  /// @param _target Timestamp at which the reserved TWAB should be for.\\n  /// @param _twabIndex Most recent TWAB index recorded.\\n  /// @return uint256 TWAB amount at `_target`.\\n  function getBalanceAt(\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    uint32 _target,\\n    uint256 _currentBalance,\\n    uint16 _twabIndex,\\n    uint16 _cardinality,\\n    uint32 _time\\n  ) internal view returns (uint256) {\\n    uint32 targetTimestamp = _target > _time ? _time : _target;\\n\\n    ObservationLib.Observation memory afterOrAt;\\n    ObservationLib.Observation memory beforeOrAt = _twabs[_twabIndex];\\n\\n    // If `targetTimestamp` is chronologically after the newest TWAB, we can simply return the current balance\\n    if (beforeOrAt.timestamp.lte(targetTimestamp, _time)) {\\n      return _currentBalance;\\n    }\\n\\n    // Now, set before to the oldest TWAB\\n    uint16 oldestTwabIndex = uint16(RingBuffer.nextIndex(_twabIndex, _cardinality));\\n    beforeOrAt = _twabs[oldestTwabIndex];\\n\\n    // If the TWAB is not initialized we go to the beginning of the TWAB circular buffer at index 0\\n    if (beforeOrAt.timestamp == 0) {\\n      oldestTwabIndex = 0;\\n      beforeOrAt = _twabs[0];\\n    }\\n\\n    // If `targetTimestamp` is chronologically before the oldest TWAB, we can early return\\n    if (targetTimestamp.lt(beforeOrAt.timestamp, _time)) {\\n      return 0;\\n    }\\n\\n    // Otherwise, we perform the `binarySearch`\\n    (beforeOrAt, afterOrAt) = binarySearch(_twabs, _twabIndex, oldestTwabIndex, _target, _cardinality, _time);\\n\\n    // Difference in amount / time\\n    uint224 differenceInAmount = afterOrAt.amount - beforeOrAt.amount;\\n    uint32 differenceInTime = afterOrAt.timestamp - beforeOrAt.timestamp;\\n\\n    return differenceInAmount / differenceInTime;\\n  }\\n\\n  /// @notice Records a new TWAB.\\n  /// @param _currentBalance Current `amount`.\\n  /// @return New TWAB that was recorded.\\n  function nextTwab(\\n    ObservationLib.Observation memory _currentTwab,\\n    uint256 _currentBalance,\\n    uint32 _time\\n  ) internal pure returns (ObservationLib.Observation memory) {\\n    // New twab amount = last twab amount (or zero) + (current amount * elapsed seconds)\\n    return ObservationLib.Observation({\\n      amount: (uint256(_currentTwab.amount) + (_currentBalance * (_time.checkedSub(_currentTwab.timestamp, _time)))).toUint224(),\\n      timestamp: _time\\n    });\\n  }\\n\\n  function calculateNextWithExpiry(\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    uint16 _nextTwabIndex,\\n    uint16 _cardinality,\\n    uint32 _time,\\n    uint32 _ttl\\n  ) internal view returns (uint16 nextAvailableTwabIndex, uint16 nextCardinality) {\\n    uint16 cardinality = _cardinality > 0 ? _cardinality : 1;\\n/*\\n    TTL: 100\\n\\n    Example 1:\\n      next twab timestamp: 100\\n\\n      existing twab timestamps:\\n      0: 10\\n      1: 90\\n\\n      we should not eliminate 0 or else the history will be 10 seconds long\\n\\n    Example 2:\\n\\n      next twab timestamp: 105\\n\\n      existing twab timestamps\\n      0: 1\\n      1: 5\\n\\n      We can eliminate 0, because the history will be 100 seconds long\\n\\n    Q: when do we eliminate the oldest twab?\\n    A: when current time - second oldest twab >= time to live\\n    */\\n\\n    ObservationLib.Observation memory secondOldestTwab;\\n    // if there are two or more records (cardinality is always one greater than # of records)\\n    if (cardinality > 2) {\\n      // get the second oldest twab\\n      secondOldestTwab = _twabs[uint16(RingBuffer.nextIndex(_nextTwabIndex, cardinality))];\\n    }\\n\\n    nextCardinality = cardinality;\\n    if (secondOldestTwab.timestamp == 0 || _time.checkedSub(secondOldestTwab.timestamp, _time) < _ttl) {\\n      nextCardinality = cardinality < MAX_CARDINALITY ? cardinality + 1 : MAX_CARDINALITY;\\n    }\\n\\n    nextAvailableTwabIndex = uint16(RingBuffer.nextIndex(_nextTwabIndex, nextCardinality));\\n  }\\n\\n  function nextTwabWithExpiry(\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    uint224 _balance,\\n    uint16 _nextTwabIndex,\\n    uint16 _cardinality,\\n    uint32 _time,\\n    uint32 _maxLifetime\\n  ) internal returns (uint16 nextAvailableTwabIndex, uint16 nextCardinality, ObservationLib.Observation memory twab, bool isNew) {\\n    ObservationLib.Observation memory newestTwab = _twabs[uint16(RingBuffer.mostRecentIndex(_nextTwabIndex, _cardinality))];\\n\\n    // if we're in the same block, return\\n    if (newestTwab.timestamp == _time) {\\n      return (_nextTwabIndex, _cardinality, newestTwab, false);\\n    }\\n\\n    (nextAvailableTwabIndex, nextCardinality) = calculateNextWithExpiry(_twabs, _nextTwabIndex, _cardinality, _time, _maxLifetime);\\n\\n    ObservationLib.Observation memory newTwab = nextTwab(\\n      newestTwab,\\n      _balance,\\n      _time\\n    );\\n\\n    _twabs[_nextTwabIndex] = newTwab;\\n\\n    return (nextAvailableTwabIndex, nextCardinality, newTwab, true);\\n  }\\n}\\n\",\"keccak256\":\"0x3ddad38c755c3ab0911918d3bb6f8d00cf25b7171d5c8c22dfec7a2dac1556c6\",\"license\":\"GPL-3.0\"},\"@pooltogether/v4-oracle-timelocks/contracts/DrawCalculatorTimelock.sol\":{\"content\":\"pragma solidity 0.8.6;\\n\\nimport \\\"@pooltogether/owner-manager-contracts/contracts/Manageable.sol\\\";\\n\\nimport \\\"./interfaces/IDrawCalculatorTimelock.sol\\\";\\n\\n/**\\n  * @title  PoolTogether V4 OracleTimelock\\n  * @author PoolTogether Inc Team\\n  * @notice OracleTimelock(s) acts as an intermediary between multiple V4 smart contracts.\\n            The OracleTimelock is responsible for pushing Draws to a DrawHistory and routing\\n            claim requests from a ClaimableDraw to a DrawCalculator. The primary objective is\\n            to  include a \\\"cooldown\\\" period for all new Draws. Allowing the correction of a\\n            malicously set Draw in the unfortunate event an Owner is compromised.\\n*/\\ncontract DrawCalculatorTimelock is IDrawCalculatorTimelock, IDrawCalculator, Manageable {\\n\\n  /* ============ Global Variables ============ */\\n\\n  /// @notice Internal DrawCalculator reference.\\n  IDrawCalculator internal immutable calculator; // 160, leaves 96\\n  \\n  /// @notice Seconds required to elapse before newest Draw is available\\n  uint32 internal timelockDuration; // take 32\\n  \\n  /// @notice Internal Timelock struct reference.\\n  Timelock internal timelock; // new word\\n\\n  /* ============ Deploy ============ */\\n\\n  /**\\n    * @notice Initialize DrawSettingsTimelockTrigger smart contract.\\n    * @param _calculator                 DrawCalculator address\\n    * @param _timelockDuration           Elapsed seconds before new Draw is available\\n  */\\n  constructor (\\n    address owner,\\n    IDrawCalculator _calculator,\\n    uint32 _timelockDuration\\n  ) Ownable(owner) {\\n    calculator = _calculator;\\n    timelockDuration = _timelockDuration;\\n  }\\n\\n  /**\\n    * @notice Routes claim/calculate requests between ClaimableDraw and DrawCalculator.\\n    * @dev    Will enforce a \\\"cooldown period between when a Draw is pushed and when users can start to claim prizes. \\n    * @param user    User address\\n    * @param drawIds Draw.drawId\\n    * @param data    Encoded pick indices\\n    * @return Prizes awardable array\\n  */\\n  function calculate(address user, uint32[] calldata drawIds, bytes calldata data) external override view returns (uint256[] memory) {\\n    Timelock memory timelock = timelock;\\n    for (uint256 i = 0; i < drawIds.length; i++) {\\n      // if draw id matches timelock and not expired, revert\\n      if (drawIds[i] == timelock.drawId) {\\n        requireTimelockElapsed(timelock);\\n      }\\n    }\\n    return calculator.calculate(user, drawIds, data);\\n    \\n  }\\n\\n  /**\\n    * @notice Push Draw onto draws ring buffer history.\\n    * @dev    Restricts new draws by forcing a push timelock.\\n    * @param _drawId Draw id\\n  */\\n  function lock(uint32 _drawId) external override onlyManagerOrOwner returns (bool) {\\n    Timelock memory _timelock = timelock;\\n    require(_drawId == _timelock.drawId + 1, \\\"OM/not-drawid-plus-one\\\");\\n    requireTimelockElapsed(_timelock);\\n    timelock = Timelock({\\n      drawId: _drawId,\\n      timestamp: uint128(block.timestamp)\\n    });\\n    return true;\\n  }\\n\\n  /**\\n    * @notice Require the timelock \\\"cooldown\\\" period has elapsed\\n  */\\n  function requireTimelockElapsed(Timelock memory _timelock) internal view {\\n    require(_timelockHasElapsed(_timelock), \\\"OM/timelock-not-expired\\\");\\n  }\\n\\n  /**\\n    * @notice Read internal DrawCalculator variable.\\n    * @return IDrawCalculator\\n  */\\n  function getDrawCalculator() external override view returns (IDrawCalculator) {\\n    return calculator;\\n  }\\n\\n  /**\\n    * @notice Read internal Timelock struct.\\n    * @return Timelock\\n  */\\n  function getTimelock() external override view returns (Timelock memory) {\\n    return timelock;\\n  }\\n\\n  /**\\n    * @notice Read internal timelockDuration variable.\\n    * @return Seconds to pass before Draw is valid.\\n  */\\n  function getTimelockDuration() external override view returns (uint32) {\\n    return timelockDuration;\\n  }\\n\\n  /**\\n    * @notice Set new Timelock struct.\\n    * @dev    Set new Timelock struct and emit TimelockSet event.\\n  */\\n  function setTimelock(Timelock memory _timelock) external override onlyOwner {\\n    timelock = _timelock;\\n\\n    emit TimelockSet(_timelock);\\n  }\\n\\n  /**\\n    * @notice Set new timelockDuration.\\n    * @dev    Set new timelockDuration and emit TimelockDurationSet event.\\n  */\\n  function setTimelockDuration(uint32 _timelockDuration) external override onlyOwner {\\n    timelockDuration = _timelockDuration;\\n\\n    emit TimelockDurationSet(_timelockDuration);\\n  }\\n\\n  /**\\n    * @notice Returns bool for timelockDuration elapsing. \\n    * @return True if timelockDuration, since last timelock has elapsed, false otherwse.\\n  */\\n  function hasElapsed() external override view returns (bool) {\\n    return _timelockHasElapsed(timelock);\\n  }\\n\\n  /**\\n    * @notice Read global DrawCalculator variable.\\n    * @return IDrawCalculator\\n  */\\n  function _timelockHasElapsed(Timelock memory timelock) internal view returns (bool) {\\n    // If the timelock hasn't been initialized, then it's elapsed\\n    if (timelock.timestamp == 0) { return true; }\\n    // otherwise if the timelock has expired, we're good.\\n    return (block.timestamp > timelock.timestamp + timelockDuration);\\n  }\\n}\",\"keccak256\":\"0x265abf2bcf5003790815818f005a19737ddfff74cbee2055ce13e7514b9ac03f\"},\"@pooltogether/v4-oracle-timelocks/contracts/interfaces/IDrawCalculatorTimelock.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"@pooltogether/v4-core/contracts/interfaces/IDrawCalculator.sol\\\";\\n\\ninterface IDrawCalculatorTimelock {\\n\\n  struct Timelock {\\n    uint128 timestamp;\\n    uint32 drawId;\\n  }\\n\\n  event TimelockSet(Timelock timelock);\\n  event TimelockDurationSet(uint32 duration);\\n\\n  // function calculate(address user, uint32[] calldata drawIds, bytes calldata data) external override view returns (uint256[] memory);\\n  function lock(uint32 drawId) external returns (bool);\\n  function getDrawCalculator() external view returns (IDrawCalculator);\\n  function getTimelock() external view returns (Timelock memory);\\n  function getTimelockDuration() external view returns (uint32);\\n  function setTimelock(Timelock memory _timelock) external;\\n  function setTimelockDuration(uint32 _timelockDuration) external;\\n  function hasElapsed() external view returns (bool);\\n}\\n\",\"keccak256\":\"0x78fd87684fc413013d72e31c08fdd4baceeee41f339d7a2a4623c8266ff49e45\",\"license\":\"GPL-3.0\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161129438038061129483398101604081905261002f916100c8565b8261003981610078565b5060609190911b6001600160601b0319166080526002805463ffffffff60a01b1916600160a01b63ffffffff9093169290920291909117905550610136565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000806000606084860312156100dd57600080fd5b83516100e88161011e565b60208501519093506100f98161011e565b604085015190925063ffffffff8116811461011357600080fd5b809150509250925092565b6001600160a01b038116811461013357600080fd5b50565b60805160601c61113961015b60003960008181610111015261057601526111396000f3fe608060405234801561001057600080fd5b50600436106100f55760003560e01c8063aaca392e11610097578063d3c45b8d11610066578063d3c45b8d1461023c578063e30c39781461024f578063f2fde38b14610260578063fdf2f3121461027357600080fd5b8063aaca392e146101de578063c9f2e0d9146101fe578063d0ebdbe714610211578063d3a9c6121461023457600080fd5b80634e71e0c8116100d35780634e71e0c81461015f5780636221a54b14610167578063715018a6146101c55780638da5cb5b146101cd57600080fd5b80630dc9c0f1146100fa5780632d680cfa1461010f578063481c6a751461014e575b600080fd5b61010d610108366004610eaf565b6102a9565b005b7f00000000000000000000000000000000000000000000000000000000000000005b6040516001600160a01b0390911681526020015b60405180910390f35b6002546001600160a01b0316610131565b61010d6103a7565b6040805180820182526000808252602091820152815180830183526003546fffffffffffffffffffffffffffffffff811680835263ffffffff600160801b909204821692840192835284519081529151169181019190915201610145565b61010d610435565b6000546001600160a01b0316610131565b6101f16101ec366004610d50565b6104aa565b6040516101459190610fc0565b61010d61020c366004610f21565b610612565b61022461021f366004610d2e565b6106f8565b6040519015158152602001610145565b610224610774565b61022461024a366004610f21565b6107b9565b6001546001600160a01b0316610131565b61010d61026e366004610d2e565b610973565b60025474010000000000000000000000000000000000000000900463ffffffff1660405163ffffffff9091168152602001610145565b336102bc6000546001600160a01b031690565b6001600160a01b0316146103175760405162461bcd60e51b815260206004820152601860248201527f4f776e61626c652f63616c6c65722d6e6f742d6f776e6572000000000000000060448201526064015b60405180910390fd5b805160038054602080850180516fffffffffffffffffffffffffffffffff90951673ffffffffffffffffffffffffffffffffffffffff199093168317600160801b63ffffffff9687160217909355604080519283529251909316928101929092527f42dd13ae53bb50ee7d7115673c106f053e02398f000e36d1e5969afc507e19ba91015b60405180910390a150565b6001546001600160a01b031633146104015760405162461bcd60e51b815260206004820152601f60248201527f4f776e61626c652f63616c6c65722d6e6f742d70656e64696e674f776e657200604482015260640161030e565b600154610416906001600160a01b0316610aaf565b6001805473ffffffffffffffffffffffffffffffffffffffff19169055565b336104486000546001600160a01b031690565b6001600160a01b03161461049e5760405162461bcd60e51b815260206004820152601860248201527f4f776e61626c652f63616c6c65722d6e6f742d6f776e65720000000000000000604482015260640161030e565b6104a86000610aaf565b565b604080518082019091526003546fffffffffffffffffffffffffffffffff81168252600160801b900463ffffffff16602082015260609060005b8581101561054557816020015163ffffffff16878783818110610509576105096110d7565b905060200201602081019061051e9190610f21565b63ffffffff1614156105335761053382610b0c565b8061053d81611088565b9150506104e4565b506040517faaca392e0000000000000000000000000000000000000000000000000000000081526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063aaca392e906105b3908a908a908a908a908a90600401610f3c565b60006040518083038186803b1580156105cb57600080fd5b505afa1580156105df573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526106079190810190610e02565b979650505050505050565b336106256000546001600160a01b031690565b6001600160a01b03161461067b5760405162461bcd60e51b815260206004820152601860248201527f4f776e61626c652f63616c6c65722d6e6f742d6f776e65720000000000000000604482015260640161030e565b600280547fffffffffffffffff00000000ffffffffffffffffffffffffffffffffffffffff167401000000000000000000000000000000000000000063ffffffff8416908102919091179091556040519081527f2607ecb03bc646643f6e6a7818db8d53cf9022e79f212f0275ab0e726ffb97de9060200161039c565b60003361070d6000546001600160a01b031690565b6001600160a01b0316146107635760405162461bcd60e51b815260206004820152601860248201527f4f776e61626c652f63616c6c65722d6e6f742d6f776e65720000000000000000604482015260640161030e565b61076c82610b64565b90505b919050565b604080518082019091526003546fffffffffffffffffffffffffffffffff81168252600160801b900463ffffffff1660208201526000906107b490610c50565b905090565b6000336107ce6002546001600160a01b031690565b6001600160a01b031614806107fc5750336107f16000546001600160a01b031690565b6001600160a01b0316145b61086e5760405162461bcd60e51b815260206004820152602660248201527f4d616e61676561626c652f63616c6c65722d6e6f742d6d616e616765722d6f7260448201527f2d6f776e65720000000000000000000000000000000000000000000000000000606482015260840161030e565b604080518082019091526003546fffffffffffffffffffffffffffffffff81168252600160801b900463ffffffff16602082018190526108af906001611069565b63ffffffff168363ffffffff16146109095760405162461bcd60e51b815260206004820152601660248201527f4f4d2f6e6f742d6472617769642d706c75732d6f6e6500000000000000000000604482015260640161030e565b61091281610b0c565b505060408051808201909152426fffffffffffffffffffffffffffffffff1680825263ffffffff9290921660209091018190526003805473ffffffffffffffffffffffffffffffffffffffff1916909217600160801b909102179055600190565b336109866000546001600160a01b031690565b6001600160a01b0316146109dc5760405162461bcd60e51b815260206004820152601860248201527f4f776e61626c652f63616c6c65722d6e6f742d6f776e65720000000000000000604482015260640161030e565b6001600160a01b038116610a585760405162461bcd60e51b815260206004820152602560248201527f4f776e61626c652f70656e64696e674f776e65722d6e6f742d7a65726f2d616460448201527f6472657373000000000000000000000000000000000000000000000000000000606482015260840161030e565b6001805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0383169081179091556040517f239a2ddded15777fa246aed5f7e1a9bc69a39d4eb4a397034d1d85766cca7d4c90600090a250565b600080546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff19831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b610b1581610c50565b610b615760405162461bcd60e51b815260206004820152601760248201527f4f4d2f74696d656c6f636b2d6e6f742d65787069726564000000000000000000604482015260640161030e565b50565b6002546000906001600160a01b03908116908316811415610bed5760405162461bcd60e51b815260206004820152602360248201527f4d616e61676561626c652f6578697374696e672d6d616e616765722d6164647260448201527f6573730000000000000000000000000000000000000000000000000000000000606482015260840161030e565b6002805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0385811691821790925560405190918316907f9cb45c728de594dab506a1f1a8554e24c8eeaf983618d5ec5dd7bc6f3c49feee90600090a350600192915050565b80516000906fffffffffffffffffffffffffffffffff16610c7357506001919050565b6002548251610ca09174010000000000000000000000000000000000000000900463ffffffff1690611035565b6fffffffffffffffffffffffffffffffff16421192915050565b80356001600160a01b038116811461076f57600080fd5b60008083601f840112610ce357600080fd5b50813567ffffffffffffffff811115610cfb57600080fd5b602083019150836020828501011115610d1357600080fd5b9250929050565b803563ffffffff8116811461076f57600080fd5b600060208284031215610d4057600080fd5b610d4982610cba565b9392505050565b600080600080600060608688031215610d6857600080fd5b610d7186610cba565b9450602086013567ffffffffffffffff80821115610d8e57600080fd5b818801915088601f830112610da257600080fd5b813581811115610db157600080fd5b8960208260051b8501011115610dc657600080fd5b602083019650809550506040880135915080821115610de457600080fd5b50610df188828901610cd1565b969995985093965092949392505050565b60006020808385031215610e1557600080fd5b825167ffffffffffffffff80821115610e2d57600080fd5b818501915085601f830112610e4157600080fd5b815181811115610e5357610e536110ed565b8060051b9150610e64848301611004565b8181528481019084860184860187018a1015610e7f57600080fd5b600095505b83861015610ea2578051835260019590950194918601918601610e84565b5098975050505050505050565b600060408284031215610ec157600080fd5b6040516040810181811067ffffffffffffffff82111715610ee457610ee46110ed565b60405282356fffffffffffffffffffffffffffffffff81168114610f0757600080fd5b8152610f1560208401610d1a565b60208201529392505050565b600060208284031215610f3357600080fd5b610d4982610d1a565b6001600160a01b038616815260606020808301829052908201859052600090869060808401835b88811015610f8c5763ffffffff610f7985610d1a565b1682529282019290820190600101610f63565b5084810360408601528581528587838301376000818701830152601f909501601f1916909401909301979650505050505050565b6020808252825182820181905260009190848201906040850190845b81811015610ff857835183529284019291840191600101610fdc565b50909695505050505050565b604051601f8201601f1916810167ffffffffffffffff8111828210171561102d5761102d6110ed565b604052919050565b60006fffffffffffffffffffffffffffffffff808316818516808303821115611060576110606110c1565b01949350505050565b600063ffffffff808316818516808303821115611060576110606110c1565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156110ba576110ba6110c1565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fdfea264697066735822122091fba82fa6dbc65445abfee9e644ca6bb82c6373fafc0f8542b4dc56b756004864736f6c63430008060033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100f55760003560e01c8063aaca392e11610097578063d3c45b8d11610066578063d3c45b8d1461023c578063e30c39781461024f578063f2fde38b14610260578063fdf2f3121461027357600080fd5b8063aaca392e146101de578063c9f2e0d9146101fe578063d0ebdbe714610211578063d3a9c6121461023457600080fd5b80634e71e0c8116100d35780634e71e0c81461015f5780636221a54b14610167578063715018a6146101c55780638da5cb5b146101cd57600080fd5b80630dc9c0f1146100fa5780632d680cfa1461010f578063481c6a751461014e575b600080fd5b61010d610108366004610eaf565b6102a9565b005b7f00000000000000000000000000000000000000000000000000000000000000005b6040516001600160a01b0390911681526020015b60405180910390f35b6002546001600160a01b0316610131565b61010d6103a7565b6040805180820182526000808252602091820152815180830183526003546fffffffffffffffffffffffffffffffff811680835263ffffffff600160801b909204821692840192835284519081529151169181019190915201610145565b61010d610435565b6000546001600160a01b0316610131565b6101f16101ec366004610d50565b6104aa565b6040516101459190610fc0565b61010d61020c366004610f21565b610612565b61022461021f366004610d2e565b6106f8565b6040519015158152602001610145565b610224610774565b61022461024a366004610f21565b6107b9565b6001546001600160a01b0316610131565b61010d61026e366004610d2e565b610973565b60025474010000000000000000000000000000000000000000900463ffffffff1660405163ffffffff9091168152602001610145565b336102bc6000546001600160a01b031690565b6001600160a01b0316146103175760405162461bcd60e51b815260206004820152601860248201527f4f776e61626c652f63616c6c65722d6e6f742d6f776e6572000000000000000060448201526064015b60405180910390fd5b805160038054602080850180516fffffffffffffffffffffffffffffffff90951673ffffffffffffffffffffffffffffffffffffffff199093168317600160801b63ffffffff9687160217909355604080519283529251909316928101929092527f42dd13ae53bb50ee7d7115673c106f053e02398f000e36d1e5969afc507e19ba91015b60405180910390a150565b6001546001600160a01b031633146104015760405162461bcd60e51b815260206004820152601f60248201527f4f776e61626c652f63616c6c65722d6e6f742d70656e64696e674f776e657200604482015260640161030e565b600154610416906001600160a01b0316610aaf565b6001805473ffffffffffffffffffffffffffffffffffffffff19169055565b336104486000546001600160a01b031690565b6001600160a01b03161461049e5760405162461bcd60e51b815260206004820152601860248201527f4f776e61626c652f63616c6c65722d6e6f742d6f776e65720000000000000000604482015260640161030e565b6104a86000610aaf565b565b604080518082019091526003546fffffffffffffffffffffffffffffffff81168252600160801b900463ffffffff16602082015260609060005b8581101561054557816020015163ffffffff16878783818110610509576105096110d7565b905060200201602081019061051e9190610f21565b63ffffffff1614156105335761053382610b0c565b8061053d81611088565b9150506104e4565b506040517faaca392e0000000000000000000000000000000000000000000000000000000081526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063aaca392e906105b3908a908a908a908a908a90600401610f3c565b60006040518083038186803b1580156105cb57600080fd5b505afa1580156105df573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526106079190810190610e02565b979650505050505050565b336106256000546001600160a01b031690565b6001600160a01b03161461067b5760405162461bcd60e51b815260206004820152601860248201527f4f776e61626c652f63616c6c65722d6e6f742d6f776e65720000000000000000604482015260640161030e565b600280547fffffffffffffffff00000000ffffffffffffffffffffffffffffffffffffffff167401000000000000000000000000000000000000000063ffffffff8416908102919091179091556040519081527f2607ecb03bc646643f6e6a7818db8d53cf9022e79f212f0275ab0e726ffb97de9060200161039c565b60003361070d6000546001600160a01b031690565b6001600160a01b0316146107635760405162461bcd60e51b815260206004820152601860248201527f4f776e61626c652f63616c6c65722d6e6f742d6f776e65720000000000000000604482015260640161030e565b61076c82610b64565b90505b919050565b604080518082019091526003546fffffffffffffffffffffffffffffffff81168252600160801b900463ffffffff1660208201526000906107b490610c50565b905090565b6000336107ce6002546001600160a01b031690565b6001600160a01b031614806107fc5750336107f16000546001600160a01b031690565b6001600160a01b0316145b61086e5760405162461bcd60e51b815260206004820152602660248201527f4d616e61676561626c652f63616c6c65722d6e6f742d6d616e616765722d6f7260448201527f2d6f776e65720000000000000000000000000000000000000000000000000000606482015260840161030e565b604080518082019091526003546fffffffffffffffffffffffffffffffff81168252600160801b900463ffffffff16602082018190526108af906001611069565b63ffffffff168363ffffffff16146109095760405162461bcd60e51b815260206004820152601660248201527f4f4d2f6e6f742d6472617769642d706c75732d6f6e6500000000000000000000604482015260640161030e565b61091281610b0c565b505060408051808201909152426fffffffffffffffffffffffffffffffff1680825263ffffffff9290921660209091018190526003805473ffffffffffffffffffffffffffffffffffffffff1916909217600160801b909102179055600190565b336109866000546001600160a01b031690565b6001600160a01b0316146109dc5760405162461bcd60e51b815260206004820152601860248201527f4f776e61626c652f63616c6c65722d6e6f742d6f776e65720000000000000000604482015260640161030e565b6001600160a01b038116610a585760405162461bcd60e51b815260206004820152602560248201527f4f776e61626c652f70656e64696e674f776e65722d6e6f742d7a65726f2d616460448201527f6472657373000000000000000000000000000000000000000000000000000000606482015260840161030e565b6001805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0383169081179091556040517f239a2ddded15777fa246aed5f7e1a9bc69a39d4eb4a397034d1d85766cca7d4c90600090a250565b600080546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff19831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b610b1581610c50565b610b615760405162461bcd60e51b815260206004820152601760248201527f4f4d2f74696d656c6f636b2d6e6f742d65787069726564000000000000000000604482015260640161030e565b50565b6002546000906001600160a01b03908116908316811415610bed5760405162461bcd60e51b815260206004820152602360248201527f4d616e61676561626c652f6578697374696e672d6d616e616765722d6164647260448201527f6573730000000000000000000000000000000000000000000000000000000000606482015260840161030e565b6002805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0385811691821790925560405190918316907f9cb45c728de594dab506a1f1a8554e24c8eeaf983618d5ec5dd7bc6f3c49feee90600090a350600192915050565b80516000906fffffffffffffffffffffffffffffffff16610c7357506001919050565b6002548251610ca09174010000000000000000000000000000000000000000900463ffffffff1690611035565b6fffffffffffffffffffffffffffffffff16421192915050565b80356001600160a01b038116811461076f57600080fd5b60008083601f840112610ce357600080fd5b50813567ffffffffffffffff811115610cfb57600080fd5b602083019150836020828501011115610d1357600080fd5b9250929050565b803563ffffffff8116811461076f57600080fd5b600060208284031215610d4057600080fd5b610d4982610cba565b9392505050565b600080600080600060608688031215610d6857600080fd5b610d7186610cba565b9450602086013567ffffffffffffffff80821115610d8e57600080fd5b818801915088601f830112610da257600080fd5b813581811115610db157600080fd5b8960208260051b8501011115610dc657600080fd5b602083019650809550506040880135915080821115610de457600080fd5b50610df188828901610cd1565b969995985093965092949392505050565b60006020808385031215610e1557600080fd5b825167ffffffffffffffff80821115610e2d57600080fd5b818501915085601f830112610e4157600080fd5b815181811115610e5357610e536110ed565b8060051b9150610e64848301611004565b8181528481019084860184860187018a1015610e7f57600080fd5b600095505b83861015610ea2578051835260019590950194918601918601610e84565b5098975050505050505050565b600060408284031215610ec157600080fd5b6040516040810181811067ffffffffffffffff82111715610ee457610ee46110ed565b60405282356fffffffffffffffffffffffffffffffff81168114610f0757600080fd5b8152610f1560208401610d1a565b60208201529392505050565b600060208284031215610f3357600080fd5b610d4982610d1a565b6001600160a01b038616815260606020808301829052908201859052600090869060808401835b88811015610f8c5763ffffffff610f7985610d1a565b1682529282019290820190600101610f63565b5084810360408601528581528587838301376000818701830152601f909501601f1916909401909301979650505050505050565b6020808252825182820181905260009190848201906040850190845b81811015610ff857835183529284019291840191600101610fdc565b50909695505050505050565b604051601f8201601f1916810167ffffffffffffffff8111828210171561102d5761102d6110ed565b604052919050565b60006fffffffffffffffffffffffffffffffff808316818516808303821115611060576110606110c1565b01949350505050565b600063ffffffff808316818516808303821115611060576110606110c1565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156110ba576110ba6110c1565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fdfea264697066735822122091fba82fa6dbc65445abfee9e644ca6bb82c6373fafc0f8542b4dc56b756004864736f6c63430008060033",
  "devdoc": {
    "author": "PoolTogether Inc Team",
    "kind": "dev",
    "methods": {
      "calculate(address,uint32[],bytes)": {
        "details": "Will enforce a \"cooldown period between when a Draw is pushed and when users can start to claim prizes. ",
        "params": {
          "data": "Encoded pick indices",
          "drawIds": "Draw.drawId",
          "user": "User address"
        },
        "returns": {
          "_0": "Prizes awardable array"
        }
      },
      "claimOwnership()": {
        "details": "This function is only callable by the `_pendingOwner`."
      },
      "constructor": {
        "params": {
          "_calculator": "DrawCalculator address",
          "_timelockDuration": "Elapsed seconds before new Draw is available"
        }
      },
      "getDrawCalculator()": {
        "returns": {
          "_0": "IDrawCalculator"
        }
      },
      "getTimelock()": {
        "returns": {
          "_0": "Timelock"
        }
      },
      "getTimelockDuration()": {
        "returns": {
          "_0": "Seconds to pass before Draw is valid."
        }
      },
      "hasElapsed()": {
        "returns": {
          "_0": "True if timelockDuration, since last timelock has elapsed, false otherwse."
        }
      },
      "lock(uint32)": {
        "details": "Restricts new draws by forcing a push timelock.",
        "params": {
          "_drawId": "Draw id"
        }
      },
      "manager()": {
        "returns": {
          "_0": "Current `_manager` address."
        }
      },
      "pendingOwner()": {
        "returns": {
          "_0": "Current `_pendingOwner` address."
        }
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "setManager(address)": {
        "details": "Throws if called by any account other than the owner.",
        "params": {
          "_newManager": "New _manager address."
        },
        "returns": {
          "_0": "Boolean to indicate if the operation was successful or not."
        }
      },
      "setTimelock((uint128,uint32))": {
        "details": "Set new Timelock struct and emit TimelockSet event."
      },
      "setTimelockDuration(uint32)": {
        "details": "Set new timelockDuration and emit TimelockDurationSet event."
      },
      "transferOwnership(address)": {
        "params": {
          "_newOwner": "Address to transfer ownership to."
        }
      }
    },
    "title": "PoolTogether V4 OracleTimelock",
    "version": 1
  },
  "userdoc": {
    "events": {
      "ClaimableDrawSet(address)": {
        "notice": "Emitted when the claimableDraw is set/updated"
      },
      "Deployed(address)": {
        "notice": "Emitted when the contract is initialized"
      }
    },
    "kind": "user",
    "methods": {
      "calculate(address,uint32[],bytes)": {
        "notice": "Routes claim/calculate requests between ClaimableDraw and DrawCalculator."
      },
      "claimOwnership()": {
        "notice": "Allows the `_pendingOwner` address to finalize the transfer."
      },
      "constructor": {
        "notice": "Initialize DrawSettingsTimelockTrigger smart contract."
      },
      "getDrawCalculator()": {
        "notice": "Read internal DrawCalculator variable."
      },
      "getTimelock()": {
        "notice": "Read internal Timelock struct."
      },
      "getTimelockDuration()": {
        "notice": "Read internal timelockDuration variable."
      },
      "hasElapsed()": {
        "notice": "Returns bool for timelockDuration elapsing. "
      },
      "lock(uint32)": {
        "notice": "Push Draw onto draws ring buffer history."
      },
      "manager()": {
        "notice": "Gets current `_manager`."
      },
      "owner()": {
        "notice": "Returns the address of the current owner."
      },
      "pendingOwner()": {
        "notice": "Gets current `_pendingOwner`."
      },
      "renounceOwnership()": {
        "notice": "Renounce ownership of the contract."
      },
      "setManager(address)": {
        "notice": "Set or change of manager."
      },
      "setTimelock((uint128,uint32))": {
        "notice": "Set new Timelock struct."
      },
      "setTimelockDuration(uint32)": {
        "notice": "Set new timelockDuration."
      },
      "transferOwnership(address)": {
        "notice": "Allows current owner to set the `_pendingOwner` address."
      }
    },
    "notice": "OracleTimelock(s) acts as an intermediary between multiple V4 smart contracts. The OracleTimelock is responsible for pushing Draws to a DrawHistory and routing claim requests from a ClaimableDraw to a DrawCalculator. The primary objective is to  include a \"cooldown\" period for all new Draws. Allowing the correction of a malicously set Draw in the unfortunate event an Owner is compromised.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3466,
        "contract": "@pooltogether/v4-oracle-timelocks/contracts/DrawCalculatorTimelock.sol:DrawCalculatorTimelock",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 3468,
        "contract": "@pooltogether/v4-oracle-timelocks/contracts/DrawCalculatorTimelock.sol:DrawCalculatorTimelock",
        "label": "_pendingOwner",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 3364,
        "contract": "@pooltogether/v4-oracle-timelocks/contracts/DrawCalculatorTimelock.sol:DrawCalculatorTimelock",
        "label": "_manager",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      },
      {
        "astId": 12939,
        "contract": "@pooltogether/v4-oracle-timelocks/contracts/DrawCalculatorTimelock.sol:DrawCalculatorTimelock",
        "label": "timelockDuration",
        "offset": 20,
        "slot": "2",
        "type": "t_uint32"
      },
      {
        "astId": 12943,
        "contract": "@pooltogether/v4-oracle-timelocks/contracts/DrawCalculatorTimelock.sol:DrawCalculatorTimelock",
        "label": "timelock",
        "offset": 0,
        "slot": "3",
        "type": "t_struct(Timelock)13348_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_struct(Timelock)13348_storage": {
        "encoding": "inplace",
        "label": "struct IDrawCalculatorTimelock.Timelock",
        "members": [
          {
            "astId": 13345,
            "contract": "@pooltogether/v4-oracle-timelocks/contracts/DrawCalculatorTimelock.sol:DrawCalculatorTimelock",
            "label": "timestamp",
            "offset": 0,
            "slot": "0",
            "type": "t_uint128"
          },
          {
            "astId": 13347,
            "contract": "@pooltogether/v4-oracle-timelocks/contracts/DrawCalculatorTimelock.sol:DrawCalculatorTimelock",
            "label": "drawId",
            "offset": 16,
            "slot": "0",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      }
    }
  }
}